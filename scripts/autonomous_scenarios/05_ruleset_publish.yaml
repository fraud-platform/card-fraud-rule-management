# RuleSet Publishing Scenario - Full End-to-End Test
#
# THIS SCENARIO TESTS THE COMPLETE PUBLISH FLOW TO MINIO.
#
# AUTHENTICATION REQUIREMENTS (CRITICAL):
# To test the full publish flow with MinIO, SEPARATE tokens for maker and checker are REQUIRED.
#
# Current token situation:
# - M2M client (pcVcfq1F7U9WBXit3Y1QoQgc85hOQPrY) only has 'client_credentials' grant
# - Password grant is NOT enabled on M2M client (security best practice)
# - Therefore, user tokens via password grant fail with 401
# - Fallback to M2M token means maker=checker, approval is REJECTED
#
# Result:
# - With M2M token only: maker=checker → approval rejected → MinIO NOT populated
# - With separate user tokens: full publish flow → MinIO populated
#
# TEST COVERAGE:
# - Unit tests (test_*.py): Use mocked tokens with different sub claims → Tests full flow
# - Integration tests (test_integration_*.py): Use real DB+MinIO with explicit maker/checker → Tests full flow
# - Autonomous live tests: Use real Auth0 tokens → Can only test partial flow without password grant
#
# TO ENABLE FULL AUTONOMOUS TESTING:
# Option 1: Add 'password' grant to M2M client in Auth0 (not recommended - security)
# Option 2: Create test-specific Auth0 client with password grant
# Option 3: Use Resource Owner Password Credentials with a SPA client that has password grant
category: publishing
name: RuleSet Compile and Publish
description: "Complete workflow: compile ruleset version, approve, and publish to MinIO"
tags: [ruleset, v1, publishing, compile, minio, manifest]
enabled: true
idempotency_prefix: ruleset_publish

steps:
  # Step 1: Create RuleSet identity for publishing test
  - name: Create Publishing RuleSet Identity
    idempotent: true
    request:
      method: POST
      path: /api/v1/rulesets
      auth: maker
      json:
        environment: "local"
        region: "TEST"
        country: "XX"
        rule_type: "AUTH"
        name: "Publishing Test AUTH RuleSet"
        description: "Test ruleset for compile and publish workflow"
    expect:
      status: [201, 409]
      json:
        present: ["ruleset_id", "details.existing_ruleset_id"]
    save:
      - name: publish_ruleset_id
        json_path: "ruleset_id"
        default: "details.existing_ruleset_id"
    on_conflict:
      fetch: "GET /api/v1/rulesets?environment=local&region=TEST&country=XX&rule_type=AUTH&name=Publishing Test AUTH RuleSet"
      save_from: "items[0].ruleset_id"

  # Step 2: Create a rule for publishing
  - name: Create Publishing Rule
    idempotent: true
    request:
      method: POST
      path: /api/v1/rules
      auth: maker
      json:
        rule_name: "High Value Transaction Rule"
        description: "Flag high value transactions for review"
        rule_type: "AUTH"
    expect:
      status: [201, 409]
      json:
        present: ["rule_id"]
    save:
      - name: publish_rule_id
        json_path: "$.rule_id"
    on_conflict:
      fetch: "GET /api/v1/rules?rule_name=High Value Transaction Rule&rule_type=AUTH"
      save_from: "$.items[0].rule_id"

  # Step 3: Create rule version with condition
  - name: Create Publishing Rule Version
    idempotent: true
    request:
      method: POST
      path: /api/v1/rules/{publish_rule_id}/versions
      auth: maker
      json:
        condition_tree:
          logicalOperator: "AND"
          conditions:
            - field: "amount"
              operator: "GT"
              value: 10000
            - field: "currency"
              operator: "EQ"
              value: "USD"
        priority: 100
        scope:
          network: ["VISA", "MASTERCARD"]
    expect:
      status: [201, 400, 409]
      json:
        present: ["rule_version_id"]
    save:
      - name: publish_rule_version_id
        json_path: "$.rule_version_id"
    on_conflict:
      fetch: "GET /api/v1/rules/{publish_rule_id}/versions?priority=100"
      save_from: "$.items[0].rule_version_id"
    continue_on_error: true

  # Step 4: Create RuleSet version v1
  - name: Create Publishing RuleSet Version
    idempotent: true
    request:
      method: POST
      path: /api/v1/rulesets/{publish_ruleset_id}/versions
      auth: maker
      json:
        rule_version_ids: ["{publish_rule_version_id}"]
    expect:
      status: [201, 400, 409]
      json:
        present: ["ruleset_version_id", "version"]
    save:
      - name: publish_ruleset_version_id
        json_path: "$.ruleset_version_id"
      - name: publish_version_number
        json_path: "$.version"
    on_conflict:
      fetch: "GET /api/v1/rulesets/{publish_ruleset_id}/versions?limit=1"
      save_from: "$.items[0].ruleset_version_id"
    continue_on_error: true

  # Step 5: Compile RuleSet version (validates AST, generates deterministic JSON)
  # This validates the rule compilation without publishing
  # Skip if already compiled (ACTIVE/SUPERSEDED) or if version isn't ready yet
  - name: Compile RuleSet Version
    idempotent: true
    skip_if:
      db_query: "SELECT status FROM fraud_gov.ruleset_versions WHERE ruleset_version_id = :id"
      condition: "status IN ('ACTIVE', 'SUPERSEDED', 'PENDING_APPROVAL')"
    request:
      method: POST
      path: /api/v1/ruleset-versions/{publish_ruleset_version_id}/compile
      auth: maker
    expect:
      status: [200, 409, 400, 422]  # 422 = version not ready for compile
    continue_on_error: true

  # Step 6: Submit RuleSet version for approval
  - name: Submit for Approval
    idempotent: true
    skip_if:
      db_query: "SELECT status FROM fraud_gov.ruleset_versions WHERE ruleset_version_id = :id"
      condition: "status NOT IN ('DRAFT', 'REJECTED')"
    request:
      method: POST
      path: /api/v1/ruleset-versions/{publish_ruleset_version_id}/submit
      auth: maker
      json:
        idempotency_key: "{idempotency_prefix}_submit_{publish_ruleset_version_id}"
    expect:
      status: [200, 409, 400]
    continue_on_error: true

  # Step 7: Approve RuleSet version (triggers MinIO publishing for AUTH)
  # If maker=checker (same token), this will return 409 with MakerCheckerViolation
  # If separate tokens, this triggers publishing to MinIO
  - name: Approve and Publish
    idempotent: true
    skip_if:
      db_query: "SELECT status FROM fraud_gov.ruleset_versions WHERE ruleset_version_id = :id"
      condition: "status IN ('APPROVED', 'ACTIVE', 'SUPERSEDED')"
    request:
      method: POST
      path: /api/v1/ruleset-versions/{publish_ruleset_version_id}/approve
      auth: checker
      json:
        idempotency_key: "{idempotency_prefix}_approve_{publish_ruleset_version_id}"
    expect:
      status: [200, 409]  # 200 = approved, 409 = maker=checker violation
    on_conflict:
      skip_if_conflict: true  # If 409 (maker=checker), mark as passed but skip verification
    continue_on_error: true

  # Step 8: Detect if maker=checker based on approval result
  # If approval was rejected (409), we can't test full publish flow
  - name: Detect Maker Checker Status
    idempotent: true
    skip_if:
      db_query: "SELECT status FROM fraud_gov.ruleset_versions WHERE ruleset_version_id = :id"
      condition: "status IN ('APPROVED', 'ACTIVE')"
    request:
      method: GET
      path: /api/v1/ruleset-versions/{publish_ruleset_version_id}
      auth: maker
    expect:
      status: [200, 404]
    save:
      - name: maker_checker_status
        json_path: "status"
        default: "UNKNOWN"
    continue_on_error: true

  # Step 9: If approved, verify manifest record was created (artifact published to MinIO)
  - name: Verify Manifest Record
    idempotent: true
    skip_if:
      db_query: "SELECT status FROM fraud_gov.ruleset_versions WHERE ruleset_version_id = :id"
      condition: "status NOT IN ('APPROVED', 'ACTIVE')"
    request:
      method: GET
      path: /api/v1/ruleset-versions/{publish_ruleset_version_id}
      auth: maker
    expect:
      status: [200, 404]
      json:
        present: ["ruleset_version_id", "status"]
    db_assert:
      - query: "SELECT COUNT(*) FROM fraud_gov.ruleset_manifest WHERE ruleset_version_id = :id"
        condition: "status = 'APPROVED'"
        expect: ">=1"  # Manifest must exist after successful approval
    continue_on_error: true

  # Step 10: Verify manifest details (URI, checksum, size)
  - name: Verify Manifest Details
    idempotent: true
    skip_if:
      db_query: "SELECT COUNT(*) FROM fraud_gov.ruleset_manifest WHERE ruleset_version_id = :id"
      condition: "count < 1"
    db_assert:
      - query: "SELECT artifact_uri, checksum, file_size_bytes FROM fraud_gov.ruleset_manifest WHERE ruleset_version_id = :id"
        condition: "status = 'APPROVED'"
        expect_present: ["artifact_uri", "checksum"]  # Must have URI and checksum
    save:
      - name: manifest_uri
        json_path: "artifact_uri"
    continue_on_error: true

  # Step 11: Verify artifact exists in MinIO via DB artifact_uri
  - name: Verify MinIO Artifact Published
    idempotent: true
    skip_if:
      db_query: "SELECT artifact_uri FROM fraud_gov.ruleset_manifest WHERE ruleset_version_id = :id"
      condition: "artifact_uri IS NULL OR artifact_uri = ''"
    db_assert:
      - query: "SELECT artifact_uri FROM fraud_gov.ruleset_manifest WHERE ruleset_version_id = :id"
        condition: "status = 'APPROVED'"
        expect_present: ["artifact_uri"]  # URI must be populated
    continue_on_error: true

  # Step 12: FINAL STATUS - Report what happened
  - name: Final Status Report
    idempotent: true
    request:
      method: GET
      path: /api/v1/ruleset-versions/{publish_ruleset_version_id}
      auth: maker
    expect:
      status: [200, 404]
    save:
      - name: final_status
        json_path: "status"
    continue_on_error: true
